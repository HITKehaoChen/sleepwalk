<html>
  
<head>
<title>Sleepwalk</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

<table id="embeddings">
  <tr>
    <td><svg id="chart0"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart1"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart2"></svg></td>
  </tr>
  <tr>
    <td><svg id="chart3"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart4"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart5"></svg></td>
  </tr>
  <tr>
    <td><svg id="chart6"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart7"></svg></td>
    <td width="60px"></td>
    <td><svg id="chart8"></svg></td>
  </tr>
</table>

<script src="d3.v5.min.js"></script>
<script src="d3-lasso.min.js"></script>

<script>
deeprange = function(a) {
   var min = Infinity
   var max = -Infinity
   for( var i = 0; i < a.length; i++ ) {
      var x = a[i]
      var r
      if( Array.isArray(x) )
         r = deeprange( x )
      else
         r = [ x, x ]
      if( r[0] < min )
         min = r[0]
      if( r[1] > max )
         max = r[1]
   }
   return [ min, max ]
}
</script>

<script>

width = 500;

n_charts = 2;

mode = "A";

pointSize = 1.5;

set_up_chart = function() {

   scale = [];
   distanceScale = [];
   colorScale = [];

   make_colorScale = function( distanceScale ) {
      return function( d ) {
         return d3.interpolateCubehelixDefault( distanceScale(d) );
      }      
   }

   for( var ch = 0; ch < n_charts; ch++ ) {

	   scale[ch] = d3.scaleLinear()
	      .domain( deeprange( (mode == "A" ? embedding[ch] : embedding) ) )
	   	   //d3.min( embedding[ch].map( function(x) { return( d3.min(x) ) } ) ), 
	    	 //   d3.max( embedding[ch].map( function(x) { return( d3.max(x) ) } ) ) ] )
	      .range( [ 0, width ] );

	   distanceScale = d3.scaleLinear()
	      .domain( (mode == "A" ? [ 0, maxdist[ch] ] : [ 0, maxdist ]) )
	      .range( [ 0, .8 ] )
	      .clamp( true );

	   colorScale[ch] = make_colorScale( distanceScale );
   }

   for( var ch = 0; ch < n_charts; ch++ ) {
      d3.select( "#chart" + ch )
	      .attr( "width", width )
	      .attr( "height", width )
	      .selectAll("circle")
	      .data( embedding[ch].map((el, i) => el.concat(i)) )
	      .enter().append( "circle" )
	         .attr( "cx", function(d) { return scale[ch]( d[0] ) } )
	         .attr( "cy", function(d) { return scale[ch]( d[1] ) } )
	         .attr( "r", pointSize )
            .attr( "class", "point" )
	         .attr( "stroke", 0 )
	         .attr( "fill", "gray" );

      
      on_mouse_over = ( function(ch) {
         return function( d, i ) { window["new_center_cell_" + mode]( ch, i )}
      })( ch );
      d3.select( "#chart" + ch )
         .selectAll("circle")
	         .on( "mouseover", on_mouse_over );

      d3.select("#chart" + ch)
         .call(function(ch) {
            var lasso = d3.lasso()
               .items(d3.select("#chart" + ch).selectAll("circle"))
               .closePathDistance(75)
               .targetArea(d3.select("#chart" + ch))
               .on("end", function() {
                  if(!lasso.selectedItems().empty()) {
                     var selInds = lasso.selectedItems().data().map(el => el[2]);

                     if(mode == "A")
                        d3.selectAll(".point")
                           .filter(d => (selInds.indexOf(d[2]) == -1))
                              .classed("not_selected", true)
                     else
                        lasso.notSelectedItems()
                           .classed("not_selected", true);


                     jrc.sendData("sPoints", selInds.map(el => el + 1));
                  }
               })
               .on("start", function() {
                  var container;
                  if(mode == "A")
                     container = d3.select("#embeddings")
                  else
                     container = d3.select("#chart" + ch);

                  container.selectAll(".point")
                     .classed("not_selected", false);
               });
            return lasso;
         }(ch));

   }
}

new_center_cell_A = function( chart, cell ) {

   var x_sel_cell = featureMatrix[chart][ cell ]
   var distCols = Array( embedding[0].length )
   for( var j = 0; j < distCols.length; j++ ) {
      var s = 0
      for( var i = 0; i < x_sel_cell.length; i++ ) {
         var dd = x_sel_cell[i] - featureMatrix[chart][j][i]
         s += dd * dd
      }
      distCols[j] = colorScale[chart](s)
   }

   for( i = 0; i < n_charts; i++ ) {
      d3.select( "#chart" + i )
         .selectAll(".point")
         .attr( "fill", function( d, i ) { return distCols[i] } )
   }
}

new_center_cell_B = function( chart, cell ) {

   var x_sel_cell = featureMatrix[chart][ cell ]

   for( ch = 0; ch < n_charts; ch++ ) {

      var distCols = Array( embedding[ch].length )
      for( var j = 0; j < distCols.length; j++ ) {
         var s = 0
         for( var i = 0; i < x_sel_cell.length; i++ ) {
            var dd = x_sel_cell[i] - featureMatrix[ch][j][i]
            s += dd * dd
         }
         distCols[j] = colorScale[ch](s)
      }

      d3.select( "#chart" + ch )
         .selectAll("circle")
         .attr( "fill", function( d, i ) { return distCols[i] } )

   }
}

</script>
</body>

</html>